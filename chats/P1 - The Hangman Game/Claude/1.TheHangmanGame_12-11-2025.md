# 1. The Hangman Game

**Created:** 11/12/2025 18:12:32  
**Updated:** 11/12/2025 18:15:18  
**Exported:** 11/12/2025 18:25:47  
**Link:** [https://claude.ai/chat/d126695d-ce1c-4544-b62c-dfe65ad504a4](https://claude.ai/chat/d126695d-ce1c-4544-b62c-dfe65ad504a4)  

## Prompt:
11/12/2025, 6:12:35 PM

> File: 





## Response:
11/12/2025, 6:15:18 PM

I'll generate the complete folder and file structure for The Hangman Game project following MVC architecture, TypeScript best practices, and the Google Style Guide.

## 1. FOLDER STRUCTURE

```
1-TheHangmanGame/
‚îú‚îÄ‚îÄ .github/
‚îÇ   ‚îî‚îÄ‚îÄ workflows/
‚îÇ       ‚îî‚îÄ‚îÄ ci.yml
‚îú‚îÄ‚îÄ public/
‚îÇ   ‚îî‚îÄ‚îÄ favicon.ico
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ main.ts
‚îÇ   ‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ game-model.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ word-dictionary.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ guess-result.ts
‚îÇ   ‚îú‚îÄ‚îÄ views/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ game-view.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ word-display.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ alphabet-display.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ hangman-renderer.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ message-display.ts
‚îÇ   ‚îú‚îÄ‚îÄ controllers/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ game-controller.ts
‚îÇ   ‚îî‚îÄ‚îÄ styles/
‚îÇ       ‚îî‚îÄ‚îÄ main.css
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ game-model.test.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ word-dictionary.test.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ guess-result.test.ts
‚îÇ   ‚îú‚îÄ‚îÄ views/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ word-display.test.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ alphabet-display.test.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ hangman-renderer.test.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ message-display.test.ts
‚îÇ   ‚îî‚îÄ‚îÄ controllers/
‚îÇ       ‚îî‚îÄ‚îÄ game-controller.test.ts
‚îú‚îÄ‚îÄ docs/
‚îÇ   ‚îî‚îÄ‚îÄ ARCHITECTURE.md
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ tsconfig.json
‚îú‚îÄ‚îÄ vite.config.ts
‚îú‚îÄ‚îÄ jest.config.js
‚îú‚îÄ‚îÄ jest.setup.js
‚îú‚îÄ‚îÄ eslint.config.mjs
‚îú‚îÄ‚îÄ typedoc.json
‚îú‚îÄ‚îÄ index.html
‚îî‚îÄ‚îÄ README.md
```

## 2. CONFIGURATION FILES

### package.json
```json
{
  "name": "the-hangman-game",
  "version": "1.0.0",
  "description": "A responsive Single Page Application implementing the classic Hangman game with animal names",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "lint": "eslint .",
    "lint:fix": "eslint . --fix",
    "docs": "typedoc",
    "type-check": "tsc --noEmit"
  },
  "keywords": [
    "hangman",
    "game",
    "typescript",
    "mvc",
    "spa"
  ],
  "author": "Fabi√°n Gonz√°lez Lence",
  "license": "MIT",
  "devDependencies": {
    "@eslint/js": "^9.15.0",
    "@types/jest": "^29.5.14",
    "@types/node": "^22.9.1",
    "eslint": "^9.15.0",
    "eslint-config-google": "^0.14.0",
    "globals": "^15.12.0",
    "jest": "^29.7.0",
    "jest-environment-jsdom": "^29.7.0",
    "ts-jest": "^29.2.5",
    "ts-node": "^10.9.2",
    "typedoc": "^0.26.10",
    "typescript": "^5.6.3",
    "typescript-eslint": "^8.14.0",
    "vite": "^5.4.11"
  },
  "dependencies": {
    "bulma": "^1.0.2"
  }
}
```

### tsconfig.json
```json
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "forceConsistentCasingInFileNames": true,

    /* Path mapping */
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"],
      "@models/*": ["src/models/*"],
      "@views/*": ["src/views/*"],
      "@controllers/*": ["src/controllers/*"]
    }
  },
  "include": ["src"],
  "exclude": ["node_modules", "dist", "tests"]
}
```

### vite.config.ts
```typescript
import {defineConfig} from 'vite';
import {resolve} from 'path';

export default defineConfig({
  root: '.',
  publicDir: 'public',
  build: {
    outDir: 'dist',
    assetsDir: 'assets',
    sourcemap: true,
    rollupOptions: {
      input: {
        main: resolve(__dirname, 'index.html'),
      },
    },
  },
  resolve: {
    alias: {
      '@': resolve(__dirname, './src'),
      '@models': resolve(__dirname, './src/models'),
      '@views': resolve(__dirname, './src/views'),
      '@controllers': resolve(__dirname, './src/controllers'),
    },
  },
  server: {
    port: 3000,
    open: true,
  },
});
```

### jest.config.js
```javascript
/** @type {import('ts-jest').JestConfigWithTsJest} */
export default {
  preset: 'ts-jest',
  testEnvironment: 'jsdom',
  roots: ['<rootDir>/tests', '<rootDir>/src'],
  testMatch: ['**/__tests__/**/*.ts', '**/?(*.)+(spec|test).ts'],
  transform: {
    '^.+\\.ts$': ['ts-jest', {
      tsconfig: {
        esModuleInterop: true,
        allowSyntheticDefaultImports: true,
      },
    }],
  },
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1',
    '^@models/(.*)$': '<rootDir>/src/models/$1',
    '^@views/(.*)$': '<rootDir>/src/views/$1',
    '^@controllers/(.*)$': '<rootDir>/src/controllers/$1',
    '\\.(css|less|scss|sass)$': '<rootDir>/tests/__mocks__/styleMock.js',
  },
  collectCoverageFrom: [
    'src/**/*.ts',
    '!src/main.ts',
    '!src/**/*.d.ts',
  ],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80,
    },
  },
  coverageDirectory: 'coverage',
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
};
```

### jest.setup.js
```javascript
// Setup file for Jest
// Add custom matchers or global test configuration here

// Mock Canvas API for testing
HTMLCanvasElement.prototype.getContext = jest.fn(() => ({
  fillStyle: '',
  strokeStyle: '',
  lineWidth: 1,
  lineCap: 'butt',
  beginPath: jest.fn(),
  moveTo: jest.fn(),
  lineTo: jest.fn(),
  arc: jest.fn(),
  stroke: jest.fn(),
  fill: jest.fn(),
  clearRect: jest.fn(),
  fillRect: jest.fn(),
  strokeRect: jest.fn(),
}));

// Mock localStorage
const localStorageMock = {
  getItem: jest.fn(),
  setItem: jest.fn(),
  removeItem: jest.fn(),
  clear: jest.fn(),
};
global.localStorage = localStorageMock;
```

### eslint.config.mjs
```javascript
import eslint from '@eslint/js';
import tseslint from 'typescript-eslint';
import globals from 'globals';

export default tseslint.config(
    eslint.configs.recommended,
    ...tseslint.configs.recommendedTypeChecked,
    {
      languageOptions: {
        globals: {
          ...globals.browser,
          ...globals.es2021,
          ...globals.node,
        },
        parserOptions: {
          project: './tsconfig.json',
          tsconfigRootDir: import.meta.dirname,
        },
      },
      rules: {
        // Google Style Guide rules
        'indent': ['error', 2],
        'linebreak-style': ['error', 'unix'],
        'quotes': ['error', 'single'],
        'semi': ['error', 'always'],
        'max-len': ['error', {code: 100, ignoreUrls: true}],
        'no-trailing-spaces': 'error',
        'comma-dangle': ['error', 'always-multiline'],
        'object-curly-spacing': ['error', 'never'],
        'array-bracket-spacing': ['error', 'never'],
        'space-before-function-paren': ['error', {
          'anonymous': 'never',
          'named': 'never',
          'asyncArrow': 'always',
        }],
        '@typescript-eslint/explicit-function-return-type': 'warn',
        '@typescript-eslint/no-unused-vars': ['error', {
          'argsIgnorePattern': '^_',
        }],
        '@typescript-eslint/naming-convention': [
          'error',
          {
            'selector': 'default',
            'format': ['camelCase'],
          },
          {
            'selector': 'variable',
            'format': ['camelCase', 'UPPER_CASE'],
          },
          {
            'selector': 'typeLike',
            'format': ['PascalCase'],
          },
          {
            'selector': 'enumMember',
            'format': ['UPPER_CASE'],
          },
        ],
      },
    },
    {
      ignores: ['dist/**', 'node_modules/**', 'coverage/**', 'docs/**'],
    },
);
```

### typedoc.json
```json
{
  "entryPoints": ["./src"],
  "entryPointStrategy": "expand",
  "out": "./docs/api",
  "exclude": ["**/*.test.ts", "**/__tests__/**"],
  "excludePrivate": false,
  "excludeProtected": false,
  "excludeExternals": true,
  "excludeInternal": false,
  "name": "The Hangman Game - API Documentation",
  "includeVersion": true,
  "readme": "./README.md",
  "plugin": [],
  "theme": "default",
  "categorizeByGroup": true,
  "categoryOrder": ["Model", "View", "Controller", "*"],
  "navigation": {
    "includeCategories": true,
    "includeGroups": true
  }
}
```

### .gitignore
```
# Dependencies
node_modules/
package-lock.json
yarn.lock
pnpm-lock.yaml

# Build outputs
dist/
build/
*.tsbuildinfo

# Testing
coverage/
.nyc_output/
*.lcov

# Environment
.env
.env.local
.env.*.local

# IDE
.vscode/
.idea/
*.swp
*.swo
*~
.DS_Store

# Logs
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*

# Documentation
docs/api/

# Temporary files
.tmp/
temp/
*.tmp
```

## 3. MAIN CLASS SKELETONS

### src/models/guess-result.ts
```typescript
/**
 * Enumeration representing the result of a letter guess attempt.
 * @enum {string}
 * @category Model
 */
export enum GuessResult {
  /** The guessed letter is correct and present in the secret word */
  CORRECT = 'CORRECT',
  
  /** The guessed letter is incorrect and not present in the secret word */
  INCORRECT = 'INCORRECT',
  
  /** The letter has already been guessed previously */
  ALREADY_GUESSED = 'ALREADY_GUESSED',
}
```

### src/models/word-dictionary.ts
```typescript
/**
 * Manages the dictionary of animal names for the Hangman game.
 * Provides functionality to retrieve random words from the collection.
 * @category Model
 */
export class WordDictionary {
  /** Collection of animal names available for the game */
  private words: string[];

  /**
   * Creates a new WordDictionary instance and initializes the animal words.
   */
  constructor() {
    this.words = [];
    this.initializeAnimalWords();
  }

  /**
   * Retrieves a random word from the dictionary.
   * @returns A randomly selected animal name
   */
  public getRandomWord(): string {
    // TODO: Implementation
    return '';
  }

  /**
   * Returns the total number of words in the dictionary.
   * @returns The count of available words
   */
  public getWordCount(): number {
    // TODO: Implementation
    return 0;
  }

  /**
   * Initializes the internal collection with animal names.
   * @private
   */
  private initializeAnimalWords(): void {
    // TODO: Implementation
  }
}
```

### src/models/game-model.ts
```typescript
import {GuessResult} from './guess-result';
import {WordDictionary} from './word-dictionary';

/**
 * Core game logic for the Hangman game.
 * Manages game state, processes guesses, and determines victory/defeat conditions.
 * @category Model
 */
export class GameModel {
  /** The secret word to be guessed */
  private secretWord: string;
  
  /** Set of letters that have been guessed */
  private guessedLetters: Set<string>;
  
  /** Number of incorrect guess attempts made */
  private failedAttempts: number;
  
  /** Maximum number of allowed failed attempts */
  private readonly maxAttempts: number;
  
  /** Dictionary providing random words */
  private wordDictionary: WordDictionary;

  /**
   * Creates a new GameModel instance.
   * @param wordDictionary - The dictionary to use for selecting secret words
   */
  constructor(wordDictionary: WordDictionary) {
    this.wordDictionary = wordDictionary;
    this.secretWord = '';
    this.guessedLetters = new Set();
    this.failedAttempts = 0;
    this.maxAttempts = 6;
  }

  /**
   * Initializes a new game with a random word.
   */
  public initializeGame(): void {
    // TODO: Implementation
  }

  /**
   * Processes a letter guess and updates game state.
   * @param letter - The letter being guessed
   * @returns The result of the guess attempt
   */
  public guessLetter(letter: string): GuessResult {
    // TODO: Implementation
    return GuessResult.INCORRECT;
  }

  /**
   * Checks if a specific letter has already been guessed.
   * @param letter - The letter to check
   * @returns True if the letter has been guessed, false otherwise
   */
  public isLetterGuessed(letter: string): boolean {
    // TODO: Implementation
    return false;
  }

  /**
   * Generates the current state of the word with revealed letters.
   * @returns Array where each element is either the letter (if guessed) or empty string
   */
  public getRevealedWord(): string[] {
    // TODO: Implementation
    return [];
  }

  /**
   * Gets the current number of failed attempts.
   * @returns The number of incorrect guesses
   */
  public getFailedAttempts(): number {
    return this.failedAttempts;
  }

  /**
   * Gets the maximum allowed number of failed attempts.
   * @returns The maximum attempts allowed
   */
  public getMaxAttempts(): number {
    return this.maxAttempts;
  }

  /**
   * Checks if the game has ended (either victory or defeat).
   * @returns True if the game is over, false otherwise
   */
  public isGameOver(): boolean {
    // TODO: Implementation
    return false;
  }

  /**
   * Checks if the player has won the game.
   * @returns True if all letters have been correctly guessed
   */
  public isVictory(): boolean {
    // TODO: Implementation
    return false;
  }

  /**
   * Checks if the player has lost the game.
   * @returns True if maximum failed attempts reached
   */
  public isDefeat(): boolean {
    // TODO: Implementation
    return false;
  }

  /**
   * Reveals the secret word (used when game ends).
   * @returns The complete secret word
   */
  public getSecretWord(): string {
    return this.secretWord;
  }

  /**
   * Resets the game state for a new game.
   */
  public resetGame(): void {
    // TODO: Implementation
  }

  /**
   * Checks if the player has successfully guessed all letters.
   * @returns True if victory condition is met
   * @private
   */
  private checkVictoryCondition(): boolean {
    // TODO: Implementation
    return false;
  }
}
```

### src/views/word-display.ts
```typescript
/**
 * Manages the visual display of the word being guessed.
 * Creates and updates letter boxes showing the current progress.
 * @category View
 */
export class WordDisplay {
  /** Container element for the word display */
  private container: HTMLElement;
  
  /** Array of letter box elements */
  private letterBoxes: HTMLElement[];

  /**
   * Creates a new WordDisplay instance.
   * @param containerId - The ID of the container HTML element
   */
  constructor(containerId: string) {
    const element = document.getElementById(containerId);
    if (!element) {
      throw new Error(`Element with id "${containerId}" not found`);
    }
    this.container = element;
    this.letterBoxes = [];
  }

  /**
   * Renders the initial word display with empty boxes.
   * @param wordLength - The number of letters in the word
   */
  public render(wordLength: number): void {
    // TODO: Implementation
  }

  /**
   * Updates a specific letter box with a revealed letter.
   * @param index - The position of the letter (0-based)
   * @param letter - The letter to display
   */
  public updateBox(index: number, letter: string): void {
    // TODO: Implementation
  }

  /**
   * Resets the display by clearing all letter boxes.
   */
  public reset(): void {
    // TODO: Implementation
  }

  /**
   * Creates a single letter box element.
   * @returns The created letter box element
   * @private
   */
  private createLetterBox(): HTMLElement {
    // TODO: Implementation
    return document.createElement('div');
  }
}
```

### src/views/alphabet-display.ts
```typescript
/**
 * Manages the visual display of the alphabet buttons.
 * Handles button creation, state management, and click events.
 * @category View
 */
export class AlphabetDisplay {
  /** Container element for the alphabet buttons */
  private container: HTMLElement;
  
  /** Map of letters to their corresponding button elements */
  private letterButtons: Map<string, HTMLButtonElement>;

  /**
   * Creates a new AlphabetDisplay instance.
   * @param containerId - The ID of the container HTML element
   */
  constructor(containerId: string) {
    const element = document.getElementById(containerId);
    if (!element) {
      throw new Error(`Element with id "${containerId}" not found`);
    }
    this.container = element;
    this.letterButtons = new Map();
  }

  /**
   * Renders the complete alphabet of clickable buttons.
   */
  public render(): void {
    // TODO: Implementation
  }

  /**
   * Disables a specific letter button after it has been guessed.
   * @param letter - The letter to disable
   */
  public disableLetter(letter: string): void {
    // TODO: Implementation
  }

  /**
   * Enables all letter buttons (used when resetting the game).
   */
  public enableAllLetters(): void {
    // TODO: Implementation
  }

  /**
   * Attaches a click handler to all letter buttons.
   * @param handler - The function to call when a letter is clicked
   */
  public attachClickHandler(handler: (letter: string) => void): void {
    // TODO: Implementation
  }

  /**
   * Creates a button element for a specific letter.
   * @param letter - The letter for the button
   * @returns The created button element
   * @private
   */
  private createLetterButton(letter: string): HTMLButtonElement {
    // TODO: Implementation
    return document.createElement('button');
  }
}
```

### src/views/hangman-renderer.ts
```typescript
/**
 * Renders the hangman drawing on a canvas element.
 * Progressively draws body parts based on failed attempt count.
 * @category View
 */
export class HangmanRenderer {
  /** Canvas element for drawing */
  private canvas: HTMLCanvasElement;
  
  /** 2D rendering context */
  private context: CanvasRenderingContext2D;

  /**
   * Creates a new HangmanRenderer instance.
   * @param canvasId - The ID of the canvas HTML element
   */
  constructor(canvasId: string) {
    const element = document.getElementById(canvasId);
    if (!element || !(element instanceof HTMLCanvasElement)) {
      throw new Error(`Canvas element with id "${canvasId}" not found`);
    }
    this.canvas = element;
    const ctx = this.canvas.getContext('2d');
    if (!ctx) {
      throw new Error('Failed to get 2D context from canvas');
    }
    this.context = ctx;
  }

  /**
   * Renders the hangman drawing based on number of failed attempts.
   * @param attempts - The number of failed attempts (0-6)
   */
  public render(attempts: number): void {
    // TODO: Implementation
  }

  /**
   * Clears the entire canvas.
   */
  public clear(): void {
    // TODO: Implementation
  }

  /**
   * Draws the gallows structure.
   * @private
   */
  private drawGallows(): void {
    // TODO: Implementation
  }

  /**
   * Draws the head (1st failed attempt).
   * @private
   */
  private drawHead(): void {
    // TODO: Implementation
  }

  /**
   * Draws the body (2nd failed attempt).
   * @private
   */
  private drawBody(): void {
    // TODO: Implementation
  }

  /**
   * Draws the left arm (3rd failed attempt).
   * @private
   */
  private drawLeftArm(): void {
    // TODO: Implementation
  }

  /**
   * Draws the right arm (4th failed attempt).
   * @private
   */
  private drawRightArm(): void {
    // TODO: Implementation
  }

  /**
   * Draws the left leg (5th failed attempt).
   * @private
   */
  private drawLeftLeg(): void {
    // TODO: Implementation
  }

  /**
   * Draws the right leg (6th failed attempt).
   * @private
   */
  private drawRightLeg(): void {
    // TODO: Implementation
  }
}
```

### src/views/message-display.ts
```typescript
/**
 * Manages the display of game messages and the restart button.
 * Shows victory/defeat messages and attempt counter.
 * @category View
 */
export class MessageDisplay {
  /** Container element for messages */
  private container: HTMLElement;
  
  /** Restart button element */
  private restartButton: HTMLButtonElement;

  /**
   * Creates a new MessageDisplay instance.
   * @param containerId - The ID of the container HTML element
   */
  constructor(containerId: string) {
    const element = document.getElementById(containerId);
    if (!element) {
      throw new Error(`Element with id "${containerId}" not found`);
    }
    this.container = element;
    this.restartButton = document.createElement('button');
  }

  /**
   * Displays a victory message with the revealed word.
   * @param word - The secret word that was guessed
   */
  public showVictory(word: string): void {
    // TODO: Implementation
  }

  /**
   * Displays a defeat message with the secret word.
   * @param word - The secret word that was not guessed
   */
  public showDefeat(word: string): void {
    // TODO: Implementation
  }

  /**
   * Displays the current attempt counter.
   * @param current - Current number of failed attempts
   * @param max - Maximum allowed failed attempts
   */
  public showAttempts(current: number, max: number): void {
    // TODO: Implementation
  }

  /**
   * Clears all messages from the display.
   */
  public clear(): void {
    // TODO: Implementation
  }

  /**
   * Attaches a click handler to the restart button.
   * @param handler - The function to call when restart is clicked
   */
  public attachRestartHandler(handler: () => void): void {
    // TODO: Implementation
  }

  /**
   * Makes the restart button visible.
   */
  public showRestartButton(): void {
    // TODO: Implementation
  }

  /**
   * Hides the restart button.
   */
  public hideRestartButton(): void {
    // TODO: Implementation
  }
}
```

### src/views/game-view.ts
```typescript
import {WordDisplay} from './word-display';
import {AlphabetDisplay} from './alphabet-display';
import {HangmanRenderer} from './hangman-renderer';
import {MessageDisplay} from './message-display';

/**
 * Main view coordinator that composes all display components.
 * Implements the Composite pattern to manage multiple view elements.
 * @category View
 */
export class GameView {
  /** Word display component */
  private wordDisplay: WordDisplay;
  
  /** Alphabet display component */
  private alphabetDisplay: AlphabetDisplay;
  
  /** Hangman renderer component */
  private hangmanRenderer: HangmanRenderer;
  
  /** Message display component */
  private messageDisplay: MessageDisplay;

  /**
   * Creates a new GameView instance and initializes all display components.
   */
  constructor() {
    this.wordDisplay = new WordDisplay('word-container');
    this.alphabetDisplay = new AlphabetDisplay('alphabet-container');
    this.hangmanRenderer = new HangmanRenderer('hangman-canvas');
    this.messageDisplay = new MessageDisplay('message-container');
  }

  /**
   * Initializes all view components.
   */
  public initialize(): void {
    // TODO: Implementation
  }

  /**
   * Updates the word display with current letter states.
   * @param letters - Array of letters to display (empty string for unrevealed)
   */
  public updateWordBoxes(letters: string[]): void {
    // TODO: Implementation
  }

  /**
   * Disables a letter button in the alphabet display.
   * @param letter - The letter to disable
   */
  public disableLetter(letter: string): void {
    // TODO: Implementation
  }

  /**
   * Updates the attempt counter display.
   * @param current - Current number of failed attempts
   * @param max - Maximum allowed failed attempts
   */
  public updateAttemptCounter(current: number, max: number): void {
    // TODO: Implementation
  }

  /**
   * Renders the hangman drawing for the given attempt count.
   * @param attempts - Number of failed attempts
   */
  public renderHangman(attempts: number): void {
    // TODO: Implementation
  }

  /**
   * Displays a victory message with the secret word.
   * @param word - The word that was guessed
   */
  public showVictoryMessage(word: string): void {
    // TODO: Implementation
  }

  /**
   * Displays a defeat message with the secret word.
   * @param word - The word that was not guessed
   */
  public showDefeatMessage(word: string): void {
    // TODO: Implementation
  }

  /**
   * Shows the restart button.
   */
  public showRestartButton(): void {
    // TODO: Implementation
  }

  /**
   * Hides the restart button.
   */
  public hideRestartButton(): void {
    // TODO: Implementation
  }

  /**
   * Resets all view components to initial state.
   */
  public reset(): void {
    // TODO: Implementation
  }
}
```

### src/controllers/game-controller.ts
```typescript
import {GameModel} from '@models/game-model';
import {GameView} from '@views/game-view';
import {GuessResult} from '@models/guess-result';

/**
 * Main controller coordinating the game logic (Model) and user interface (View).
 * Implements the Observer pattern to handle user interactions.
 * @category Controller
 */
export class GameController {
  /** Game logic model */
  private model: GameModel;
  
  /** Game user interface */
  private view: GameView;

  /**
   * Creates a new GameController instance.
   * @param model - The game model containing business logic
   * @param view - The game view managing UI components
   */
  constructor(model: GameModel, view: GameView) {
    this.model = model;
    this.view = view;
  }

  /**
   * Initializes the game by setting up the model, view, and event handlers.
   */
  public initialize(): void {
    // TODO: Implementation
  }

  /**
   * Handles a letter click event from the alphabet display.
   * @param letter - The letter that was clicked
   */
  public handleLetterClick(letter: string): void {
    // TODO: Implementation
  }

  /**
   * Handles the restart button click event.
   */
  public handleRestartClick(): void {
    // TODO: Implementation
  }

  /**
   * Updates the view based on the result of a guess.
   * @param result - The result of the guess attempt
   * @param letter - The letter that was guessed
   * @private
   */
  private updateViewAfterGuess(result: GuessResult, letter: string): void {
    // TODO: Implementation
  }

  /**
   * Checks if the game has ended and handles the appropriate end state.
   * @private
   */
  private checkAndHandleGameEnd(): void {
    // TODO: Implementation
  }

  /**
   * Synchronizes the view with the current model state.
   * @private
   */
  private syncViewWithModel(): void {
    // TODO: Implementation
  }
}
```

### src/main.ts
```typescript
import {GameModel} from '@models/game-model';
import {GameView} from '@views/game-view';
import {GameController} from '@controllers/game-controller';
import {WordDictionary} from '@models/word-dictionary';
import './styles/main.css';
import 'bulma/css/bulma.min.css';

/**
 * Application entry point.
 * Initializes the MVC components and starts the game.
 */
function main(): void {
  // Initialize Model
  const dictionary = new WordDictionary();
  const gameModel = new GameModel(dictionary);

  // Initialize View
  const gameView = new GameView();

  // Initialize Controller
  const gameController = new GameController(gameModel, gameView);
  gameController.initialize();
}

// Start the application when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', main);
} else {
  main();
}
```

### src/styles/main.css
```css
/* Global Styles */
:root {
  --primary-color: #3273dc;
  --danger-color: #f14668;
  --success-color: #48c774;
  --text-color: #363636;
  --background-color: #f5f5f5;
}

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  background-color: var(--background-color);
  color: var(--text-color);
  min-height: 100vh;
  display: flex;
  justify-content: center;
  align-items: center;
}

/* Game Container */
#app {
  max-width: 900px;
  width: 100%;
  padding: 2rem;
}

/* Word Display */
#word-container {
  display: flex;
  justify-content: center;
  gap: 0.5rem;
  margin: 2rem 0;
  flex-wrap: wrap;
}

.letter-box {
  width: 50px;
  height: 60px;
  border: 2px solid var(--primary-color);
  border-radius: 8px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 2rem;
  font-weight: bold;
  background-color: white;
}

/* Alphabet Display */
#alphabet-container {
  display: flex;
  justify-content: center;
  gap: 0.5rem;
  flex-wrap: wrap;
  margin: 2rem 0;
}

.letter-button {
  width: 45px;
  height: 45px;
  font-size: 1.25rem;
  font-weight: bold;
  border: 2px solid var(--primary-color);
  background-color: white;
  color: var(--primary-color);
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s;
}

.letter-button:hover:not(:disabled) {
  background-color: var(--primary-color);
  color: white;
  transform: translateY(-2px);
}

.letter-button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* Hangman Canvas */
#hangman-canvas {
  display: block;
  margin: 2rem auto;
  border: 2px solid var(--primary-color);
  border-radius: 8px;
  background-color: white;
}

/* Message Display */
#message-container {
  text-align: center;
  margin: 2rem 0;
  min-height: 100px;
}

.victory-message {
  color: var(--success-color);
  font-size: 1.5rem;
  font-weight: bold;
}

.defeat-message {
  color: var(--danger-color);
  font-size: 1.5rem;
  font-weight: bold;
}

.attempt-counter {
  font-size: 1.25rem;
  margin: 1rem 0;
}

/* Restart Button */
.restart-button {
  margin-top: 1rem;
}

/* Responsive Design */
@media (max-width: 768px) {
  #app {
    padding: 1rem;
  }

  .letter-box {
    width: 40px;
    height: 50px;
    font-size: 1.5rem;
  }

  .letter-button {
    width: 40px;
    height: 40px;
    font-size: 1rem;
  }

  #hangman-canvas {
    width: 100%;
    max-width: 400px;
    height: auto;
  }
}
```

### index.html
```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Classic Hangman game with animal names - A TypeScript SPA">
  <meta name="author" content="Fabi√°n Gonz√°lez Lence">
  <title>The Hangman Game</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
</head>
<body>
  <div id="app">
    <section class="hero is-primary">
      <div class="hero-body">
        <h1 class="title has-text-centered">The Hangman Game</h1>
        <p class="subtitle has-text-centered">Guess the animal name!</p>
      </div>
    </section>

    <div class="container">
      <div class="columns is-centered">
        <div class="column is-8">
          <!-- Message Display -->
          <div id="message-container" class="box has-text-centered"></div>

          <!-- Hangman Canvas -->
          <div class="box has-text-centered">
            <canvas id="hangman-canvas" width="400" height="400"></canvas>
          </div>

          <!-- Word Display -->
          <div id="word-container" class="box"></div>

          <!-- Alphabet Display -->
          <div id="alphabet-container" class="box"></div>
        </div>
      </div>
    </div>
  </div>

  <script type="module" src="/src/main.ts"></script>
</body>
</html>
```

## 4. DOCUMENTATION FILES

### README.md
```markdown
# The Hangman Game

A responsive Single Page Application (SPA) implementing the classic Hangman game where players guess animal names letter by letter.

## üéÆ Features

- Interactive alphabet for letter selection
- Visual word progress with letter boxes
- Canvas-based hangman rendering
- Complete game state management
- Responsive design (desktop and mobile)
- Maximum 6 failed attempts
- Victory/defeat detection and messaging

## üèóÔ∏è Architecture

This project follows the **MVC (Model-View-Controller)** architectural pattern:

- **Model**: Game logic, word dictionary, and state management
- **View**: UI components (word display, alphabet, hangman canvas, messages)
- **Controller**: Coordinates user interactions between Model and View

### Design Patterns

- **MVC Pattern**: Separation of concerns
- **Observer Pattern**: Event handling for user interactions
- **Composite Pattern**: View composition of multiple display components
- **Singleton Pattern**: Single word dictionary instance

## üõ†Ô∏è Technology Stack

- **TypeScript**: Type-safe development
- **Vite**: Fast build tool and dev server
- **Bulma**: CSS framework for styling
- **Canvas API**: Hangman drawing
- **Jest**: Unit testing framework
- **ESLint**: Code linting (Google Style Guide)
- **TypeDoc**: API documentation generation

## üìã Prerequisites

- Node.js (v18 or higher)
- npm (v9 or higher)

## üöÄ Setup Instructions

### 1. Clone the repository

```bash
cd 1-TheHangmanGame
```

### 2. Install dependencies

```bash
npm install
```

### 3. Development

Start the development server:

```bash
npm run dev
```

The application will be available at `http://localhost:3000`

### 4. Build for production

```bash
npm run build
```

The production-ready files will be in the `dist/` directory.

### 5. Preview production build

```bash
npm run preview
```

## üß™ Testing

### Run all tests

```bash
npm test
```

### Run tests in watch mode

```bash
npm run test:watch
```

### Generate coverage report

```bash
npm run test:coverage
```

Coverage reports will be available in the `coverage/` directory.

## üìù Code Quality

### Run linter

```bash
npm run lint
```

### Fix linting issues automatically

```bash
npm run lint:fix
```

### Type checking

```bash
npm run type-check
```

## üìö Documentation

Generate API documentation:

```bash
npm run docs
```

Documentation will be available in `docs/api/index.html`

## üìÅ Project Structure

```
1-TheHangmanGame/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ models/          # Business logic
‚îÇ   ‚îú‚îÄ‚îÄ views/           # UI components
‚îÇ   ‚îú‚îÄ‚îÄ controllers/     # Coordination logic
‚îÇ   ‚îú‚îÄ‚îÄ styles/          # CSS styles
‚îÇ   ‚îî‚îÄ‚îÄ main.ts          # Application entry point
‚îú‚îÄ‚îÄ tests/               # Unit tests
‚îú‚îÄ‚îÄ docs/                # Documentation
‚îú‚îÄ‚îÄ public/              # Static assets
‚îî‚îÄ‚îÄ index.html           # HTML entry point
```

## üéØ Non-Functional Requirements

- **Code Coverage**: ‚â•80%
- **UI Performance**: < 200ms response time
- **Code Quality**: ESLint compliance with Google TypeScript Style Guide
- **Documentation**: Complete JSDoc/TypeDoc coverage

## üë• Author

- **Fabi√°n Gonz√°lez Lence**
- Universidad de La Laguna - Computer Engineering Degree
- Academic Year: 2025-2026

## üìÑ License

MIT

## üîó Related Documentation

- [ARCHITECTURE.md](./docs/ARCHITECTURE.md) - Detailed architectural decisions
- [API Documentation](./docs/api/index.html) - Generated TypeDoc documentation
```

### docs/ARCHITECTURE.md
```markdown
# Architecture Documentation

## Overview

The Hangman Game is built using the **Model-View-Controller (MVC)** architectural pattern, providing clear separation of concerns and maintainability.

## Architectural Decisions

### 1. MVC Pattern

**Rationale**: MVC provides a proven structure for interactive applications:
- **Model**: Encapsulates game logic independently of UI
- **View**: Manages all UI rendering without business logic
- **Controller**: Coordinates user interactions and updates

**Benefits**:
- Clear separation of concerns
- Easier testing (each layer tested independently)
- Better maintainability
- Reusable components

### 2. Composite Pattern in View Layer

The `GameView` class composes multiple specialized display components:
- `WordDisplay`: Word letter boxes
- `AlphabetDisplay`: Letter selection buttons
- `HangmanRenderer`: Canvas drawing
- `MessageDisplay`: Game messages and restart button

**Rationale**: Each component has a single responsibility, making them easier to test and maintain.

### 3. TypeScript for Type Safety

**Rationale**: TypeScript provides:
- Compile-time type checking
- Better IDE support (autocomplete, refactoring)
- Self-documenting code through type annotations
- Easier refactoring and maintenance

### 4. Vite as Build Tool

**Rationale**: Vite offers:
- Lightning-fast HMR (Hot Module Replacement)
- Optimized production builds
- Native ES modules support
- Simple configuration

### 5. Canvas API for Hangman Drawing

**Rationale**: Canvas provides:
- Full control over drawing primitives
- Smooth progressive rendering
- Good performance
- No external dependencies for graphics

### 6. Bulma CSS Framework

**Rationale**: Bulma offers:
- Modern, responsive design
- Flexbox-based layout
- Minimal JavaScript dependencies
- Easy customization

## Component Interaction Flow

```
User Click ‚Üí AlphabetDisplay (View)
              ‚Üì
           GameController
              ‚Üì
           GameModel (validate & process)
              ‚Üì
           GameController (update view)
              ‚Üì
Multiple View Components (WordDisplay, HangmanRenderer, MessageDisplay)
```

## State Management

State is centralized in the `GameModel`:
- `secretWord`: Current word to guess
- `guessedLetters`: Set of already guessed letters
- `failedAttempts`: Count of incorrect guesses
- `maxAttempts`: Maximum allowed failures (6)

## Testing Strategy

### Unit Tests
- **Models**: Test business logic in isolation
- **Views**: Test DOM manipulation and rendering
- **Controllers**: Test coordination logic with mocked dependencies

### Coverage Goals
- Minimum 80% code coverage
- All public methods tested
- Edge cases covered

### Test Structure
```
tests/
‚îú‚îÄ‚îÄ models/
‚îú‚îÄ‚îÄ views/
‚îî‚îÄ‚îÄ controllers/
```

## Performance Considerations

1. **UI Updates**: < 200ms response time for letter selection
2. **Canvas Rendering**: Efficient drawing with minimal redraws
3. **DOM Manipulation**: Batch updates where possible
4. **Event Handlers**: Debouncing if needed for rapid clicks

## Security Considerations

1. **Input Validation**: All user inputs validated
2. **No Eval**: No dynamic code execution
3. **XSS Prevention**: Proper escaping of user-provided content
4. **CSP Headers**: Content Security Policy in production

## Scalability

### Current Scope
- Single-player game
- Fixed word list
- Local state only

### Future Extensions
- Multiplayer support
- Backend API for word lists
- User accounts and statistics
- Difficulty levels
- Different categories (not just animals)
- Sound effects and animations

## Browser Compatibility

**Target Browsers**:
- Chrome/Edge (latest 2 versions)
- Firefox (latest 2 versions)
- Safari (latest 2 versions)
- Mobile browsers (iOS Safari, Chrome Mobile)

## Build & Deployment

### Development
```bash
npm run dev
```

### Production Build
```bash
npm run build
```

### Deployment
Static files in `dist/` can be deployed to:
- GitHub Pages
- Netlify
- Vercel
- Any static hosting service

## Documentation Standards

### Code Documentation
- JSDoc comments for all public APIs
- TypeDoc for generating HTML documentation
- Inline comments for complex logic

### API Documentation
```bash
npm run docs
```

## Continuous Integration

GitHub Actions workflow includes:
1. Linting (ESLint)
2. Type checking (TypeScript)
3. Unit tests (Jest)
4. Coverage reporting
5. Build verification
6. Documentation generation

## Non-Functional Requirements Compliance

| Requirement | Implementation | Verification |
|-------------|----------------|--------------|
| Maintainability | MVC architecture, modular code | Code review, ESLint |
| Testability | ‚â•80% coverage | Jest reports |
| Performance | UI updates < 200ms | Performance tests |
| Responsiveness | Bulma framework, media queries | Manual testing |
| Code Quality | Google Style Guide | ESLint |
| Documentation | JSDoc/TypeDoc | Generated docs |

## References

- [MVC Pattern](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller)
- [TypeScript Handbook](https://www.typescriptlang.org/docs/)
- [Vite Documentation](https://vitejs.dev/)
- [Canvas API](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API)
- [Bulma Documentation](https://bulma.io/documentation/)
```

### .github/workflows/ci.yml
```yaml
name: CI

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

jobs:
  test:
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        node-version: [18.x, 20.x]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'
          cache-dependency-path: '1-TheHangmanGame/package-lock.json'
      
      - name: Install dependencies
        working-directory: 1-TheHangmanGame
        run: npm ci
      
      - name: Run linter
        working-directory: 1-TheHangmanGame
        run: npm run lint
      
      - name: Run type check
        working-directory: 1-TheHangmanGame
        run: npm run type-check
      
      - name: Run tests
        working-directory: 1-TheHangmanGame
        run: npm run test:coverage
      
      - name: Upload coverage reports
        uses: codecov/codecov-action@v4
        with:
          file: 1-TheHangmanGame/coverage/lcov.info
          flags: unittests
          name: codecov-umbrella
      
      - name: Build project
        working-directory: 1-TheHangmanGame
        run: npm run build
      
      - name: Generate documentation
        working-directory: 1-TheHangmanGame
        run: npm run docs
```

## 5. INITIALIZATION COMMANDS

```bash
# Navigate to project directory
cd 1-TheHangmanGame

# Initialize npm project (package.json already provided)
npm init -y

# Install production dependencies
npm install bulma

# Install development dependencies
npm install --save-dev \
  @eslint/js \
  @types/jest \
  @types/node \
  eslint \
  eslint-config-google \
  globals \
  jest \
  jest-environment-jsdom \
  ts-jest \
  ts-node \
  typedoc \
  typescript \
  typescript-eslint \
  vite

# Create necessary directories
mkdir -p src/models src/views src/controllers src/styles
mkdir -p tests/models tests/views tests/controllers
mkdir -p tests/__mocks__
mkdir -p docs
mkdir -p public
mkdir -p .github/workflows

# Create style mock for Jest
echo "module.exports = {};" > tests/__mocks__/styleMock.js

# Initialize Git (if not already in repository)
# Note: Since 1-TheHangmanGame is a subdirectory, 
# no need to initialize git here

# Verify installation
npm run type-check
npm run lint
npm test

# Start development server
npm run dev
```

## 6. ARCHITECTURAL JUSTIFICATION

### Why MVC?

1. **Separation of Concerns**: Each layer has distinct responsibilities
2. **Testability**: Each component can be tested in isolation
3. **Maintainability**: Changes in one layer don't affect others
4. **Scalability**: Easy to extend with new features

### Why TypeScript?

1. **Type Safety**: Catch errors at compile-time
2. **Better Refactoring**: IDE support for safe refactoring
3. **Documentation**: Types serve as inline documentation
4. **Industry Standard**: Widely adopted in modern web development

### Why Vite?

1. **Speed**: Instant server start and fast HMR
2. **Modern**: Native ES modules support
3. **Simple**: Minimal configuration required
4. **Optimized**: Excellent production builds

### Why Canvas API?

1. **Control**: Full control over rendering
2. **Performance**: Efficient for 2D graphics
3. **Progressive**: Easy to draw hangman parts sequentially
4. **No Dependencies**: Built into browsers

### Why Bulma?

1. **Modern**: Flexbox-based responsive design
2. **Lightweight**: No JavaScript dependencies
3. **Customizable**: Easy to override with custom CSS
4. **Documentation**: Excellent documentation

### Testing Strategy

1. **Jest**: Industry-standard testing framework
2. **ts-jest**: Seamless TypeScript integration
3. **jsdom**: Browser environment simulation
4. **High Coverage**: 80% minimum ensures quality

This structure provides a solid foundation for developing The Hangman Game while adhering to best practices in TypeScript development, testing, and documentation.





---
Powered by [Claude Exporter](https://www.claudexporter.com)